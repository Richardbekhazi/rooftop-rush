<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Santa's Rooftop Rush</title>
    <!-- Import Google Fonts for nice UI -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@600;800&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Nunito', sans-serif;
            background-color: #87CEEB; /* Start with Day Blue */
            user-select: none;
        }

        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            padding: 20px; box-sizing: border-box;
        }

        /* HUD Styles */
        .hud-top { display: flex; justify-content: space-between; width: 100%; }
        .badge-container { display: flex; gap: 15px; }
        
        .badge {
            background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(5px);
            padding: 10px 20px; border-radius: 50px;
            color: white; font-size: 20px; font-weight: 800;
            display: flex; align-items: center; gap: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-family: 'Fredoka One', cursive; letter-spacing: 1px;
        }
        .badge.gift-badge { background: linear-gradient(135deg, #ef4444, #b91c1c); border-color: #fca5a5; }

        /* Menu Screens */
        #start-screen, #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 10; transition: opacity 0.3s;
        }

        #start-screen { background: rgba(11, 16, 38, 0.4); backdrop-filter: blur(2px); }
        #game-over-screen { background: rgba(11, 16, 38, 0.8); backdrop-filter: blur(8px); }

        .start-content { text-align: center; animation: popIn 0.5s ease-out; }
        
        /* Card Style for Game Over */
        .menu-card {
            background: rgba(255, 255, 255, 0.95); padding: 40px 60px; border-radius: 30px;
            text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.3), 0 0 0 10px rgba(255, 255, 255, 0.2);
            max-width: 90%; border: 4px solid #e2e8f0;
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        h1 {
            font-family: 'Fredoka One', cursive; color: #ef4444; font-size: 80px;
            margin: 0; text-transform: uppercase;
            text-shadow: 4px 4px 0px #fee2e2, 0 0 20px rgba(239, 68, 68, 0.5);
            line-height: 1.1;
        }
        h2 {
            color: #f1f5f9; margin-top: 10px; margin-bottom: 40px;
            font-size: 28px; font-weight: 800; text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        /* Specific overrides for Game Over card */
        .menu-card h1 { font-size: 48px; color: #f59e0b; text-shadow: none; }
        .menu-card h2 { color: #64748b; font-size: 20px; text-shadow: none; margin-bottom: 15px; }

        /* Stats Display */
        .score-display-full {
            background: rgba(255,255,255,0.15); backdrop-filter: blur(10px);
            padding: 15px 30px; border-radius: 20px; display: inline-block; margin-bottom: 40px;
            border: 2px solid rgba(255,255,255,0.3);
        }
        .score-label-full { display: block; color: #e2e8f0; font-size: 16px; margin-bottom: 5px; font-weight: 700; }
        .score-value-full { color: #fbbf24; font-size: 32px; font-family: 'Fredoka One', cursive; }

        .score-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 25px; }
        .score-box { background: #f1f5f9; padding: 15px; border-radius: 15px; text-align: center; }
        .score-label { display: block; font-size: 14px; color: #64748b; font-weight: 800; margin-bottom: 5px; }
        .score-value { font-size: 24px; color: #334155; font-family: 'Fredoka One', cursive; }
        .wallet-highlight { color: #ea580c; }

        /* Buttons */
        .btn-group { display: flex; flex-direction: column; gap: 15px; width: 100%; max-width: 400px; margin: 0 auto; }
        .btn {
            font-family: 'Fredoka One', cursive; font-size: 24px; padding: 18px 0;
            border: none; border-radius: 15px; cursor: pointer; width: 100%;
            transition: transform 0.1s, filter 0.2s; color: white;
            text-shadow: 0 2px 0 rgba(0,0,0,0.1); position: relative; overflow: hidden;
        }
        .btn:hover { transform: translateY(-4px); filter: brightness(1.1); }
        .btn:active { transform: translateY(2px); }
        .btn-green { background: linear-gradient(to bottom, #22c55e, #16a34a); box-shadow: 0 6px 0 #15803d; }
        .btn-orange { background: linear-gradient(to bottom, #f59e0b, #d97706); box-shadow: 0 6px 0 #b45309; }
        .btn-blue { background: linear-gradient(to bottom, #3b82f6, #2563eb); box-shadow: 0 6px 0 #1d4ed8; }
        .btn-gray { background: linear-gradient(to bottom, #64748b, #475569); box-shadow: 0 6px 0 #334155; }
        .btn:disabled { background: #cbd5e1; box-shadow: none; color: #94a3b8; cursor: not-allowed; transform: none; filter: none; }

        .controls-hint {
            margin-top: 40px; color: #e2e8f0; font-size: 16px; font-weight: 800;
            background: rgba(0,0,0,0.3); padding: 15px 30px; border-radius: 30px; backdrop-filter: blur(5px);
        }
        .key-icon {
            background: #f8fafc; padding: 4px 8px; border-radius: 6px; color: #0f172a;
            border-bottom: 3px solid #cbd5e1; display: inline-block; margin: 0 3px;
        }
        .hidden { display: none !important; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="hud" class="hud-top hidden">
            <div class="badge-container">
                <div class="badge gift-badge">üéÅ <span id="total-gift-count">0</span></div>
                <div class="badge">üö© <span id="dist-count">0</span>m</div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <div class="start-content">
            <h1>Rooftop Rush</h1>
            <h2>üéÖ Help Santa Deliver Gifts!</h2>
            <div class="score-display-full">
                <span class="score-label-full">TOTAL SAVED GIFTS</span>
                <span class="score-value-full" id="start-wallet-display">0</span>
            </div>
            <div class="btn-group">
                <button class="btn btn-green" id="start-btn">PLAY NOW</button>
            </div>
            <div class="controls-hint">
                <span class="key-icon">WASD</span> Move ‚Ä¢ <span class="key-icon">SPACE</span> Jump ‚Ä¢ <span class="key-icon">‚Üì</span> Roll (Duck)
            </div>
        </div>
    </div>

    <div id="game-over-screen" class="hidden">
        <div class="menu-card">
            <h1>Ouch!</h1>
            <h2>Run Ended</h2>
            <div class="score-grid">
                <div class="score-box">
                    <span class="score-label">Distance</span>
                    <span class="score-value" id="final-dist">0m</span>
                </div>
                <div class="score-box">
                    <span class="score-label">Available Gifts</span>
                    <span class="score-value wallet-highlight" id="final-wallet">0</span>
                </div>
            </div>
            <div class="btn-group">
                <button class="btn btn-orange" id="continue-btn">Continue</button>
                <button class="btn btn-blue" id="restart-btn">Restart Run</button>
                <button class="btn btn-gray" id="menu-btn">Main Menu</button>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const LANE_WIDTH = 4;
        const LANES = [-LANE_WIDTH, 0, LANE_WIDTH];
        const GRAVITY = 0.025;
        const JUMP_FORCE = 0.65;
        const SPEED_INITIAL = 0.5;
        const SPEED_MAX = 1.4;
        
        // --- State ---
        let scene, camera, renderer;
        let player, reindeer;
        let playerLane = 1; 
        let targetX = 0; 
        let verticalVelocity = 0;
        let isJumping = false; 
        let isRolling = false; 
        let rollTimer = 0;
        
        let gameActive = false; 
        let gameSpeed = SPEED_INITIAL; 
        let distance = 0;
        
        // Persist wallet in localStorage
        let totalWallet = parseInt(localStorage.getItem('santaRunnerGifts')) || 0;
        let reviveCount = 0;
        
        let groundSegments = [], obstacles = [], collectables = [], particles = [];
        let sunMoon, stars, hemiLight, dirLight, windowMaterial; 
        let animationId;

        // --- UI Elements ---
        const hudEl = document.getElementById('hud');
        const totalGiftCountEl = document.getElementById('total-gift-count');
        const distCountEl = document.getElementById('dist-count');
        const startScreen = document.getElementById('start-screen');
        const startWalletDisplay = document.getElementById('start-wallet-display');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalDistEl = document.getElementById('final-dist');
        const finalWalletEl = document.getElementById('final-wallet');
        const continueBtn = document.getElementById('continue-btn');
        const restartBtn = document.getElementById('restart-btn');
        const menuBtn = document.getElementById('menu-btn');
        
        const COLORS = {
            skyNight: 0x0b1026, skyDay: 0x87CEEB, snow: 0xffffff,
            roof: 0x2d3748, roofDark: 0x1a202c, brick: 0x8b4513,
            window: 0xffcc00, santaRed: 0xe11d48, reindeer: 0x8B4513,
            antler: 0xE3DAC9, tree: 0x166534, gold: 0xf59e0b,
            moon: 0xffffeb, sun: 0xffd700, droneMetal: 0x475569,
            skin: 0xffdecb, boot: 0x111111
        };

        const COLOR_GIFT_BOX = [0xd62828, 0x22c55e, 0x3b82f6, 0xf59e0b, 0xa855f7];

        // --- Helper: Glow Texture ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grd.addColorStop(0, 'rgba(255,255,255,1)'); grd.addColorStop(0.4, 'rgba(255,255,255,0.5)'); grd.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grd; ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }
        const glowTexture = createGlowTexture();

        // --- Setup ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.skyDay);
            scene.fog = new THREE.FogExp2(COLORS.skyDay, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 150);
            camera.position.set(0, 7, 16); camera.lookAt(0, 2, -6);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            hemiLight = new THREE.HemisphereLight(0x4c5c7a, 0x1a202c, 1.5); scene.add(hemiLight);
            dirLight = new THREE.DirectionalLight(0xffffff, 3.0);
            dirLight.position.set(30, 50, -20); dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);
            const ambient = new THREE.AmbientLight(0x1e3a8a, 0.3); scene.add(ambient);

            createEnvironment();
            createPlayer();
            createSnow();
            updateWalletUI();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', handleKeyDown);
            setupTouchControls();

            document.getElementById('start-btn').addEventListener('click', startGame);
            restartBtn.addEventListener('click', resetGame);
            continueBtn.addEventListener('click', continueGame);
            menuBtn.addEventListener('click', returnToMenu);

            renderer.render(scene, camera);
        }

        function updateWalletUI() {
            totalGiftCountEl.innerText = totalWallet;
            startWalletDisplay.innerText = totalWallet;
            finalWalletEl.innerText = totalWallet;
        }

        function createEnvironment() {
            // Celestial Body
            const moonGeo = new THREE.SphereGeometry(8, 32, 32);
            const moonMat = new THREE.MeshBasicMaterial({ color: COLORS.sun, fog: false });
            sunMoon = new THREE.Mesh(moonGeo, moonMat);
            sunMoon.position.set(30, 40, -80); scene.add(sunMoon);

            const spriteMat = new THREE.SpriteMaterial({ map: glowTexture, color: 0xffaa00, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
            const glow = new THREE.Sprite(spriteMat); glow.scale.set(60, 60, 1); sunMoon.add(glow);
            
            // Stars
            const starGeo = new THREE.BufferGeometry();
            const count = 800;
            const positions = new Float32Array(count * 3);
            for(let i=0; i<count*3; i++) positions[i] = (Math.random() - 0.5) * 300;
            starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, map: glowTexture, transparent: true, alphaTest: 0.1, opacity: 0 });
            stars = new THREE.Points(starGeo, starMat); stars.position.y = 20; scene.add(stars);

            // Shared Material
            windowMaterial = new THREE.MeshStandardMaterial({ color: COLORS.window, emissive: COLORS.window, emissiveIntensity: 0 });

            // Initial Floor
            for (let i = 0; i < 15; i++) spawnGroundSegment(-i * 12);
        }

        // --- HIGH DETAIL PLAYER CREATION ---
        function createPlayer() {
            player = new THREE.Group();
            const matStandard = (col, rough=0.7) => new THREE.MeshStandardMaterial({ color: col, flatShading: true, roughness: rough });

            // --- REINDEER ---
            const reindeerGroup = new THREE.Group();
            
            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.4, 2.6), matStandard(COLORS.reindeer));
            body.position.y = 0.7; body.castShadow = true; reindeerGroup.add(body);
            // Tail
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), matStandard(0xffffff));
            tail.position.set(0, 1.2, 1.3); reindeerGroup.add(tail);
            // Neck & Head
            const neck = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.2, 1), matStandard(COLORS.reindeer));
            neck.position.set(0, 1.5, -1.1); neck.rotation.x = -0.3; reindeerGroup.add(neck);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.9, 1.4), matStandard(COLORS.reindeer));
            head.position.set(0, 2.2, -1.7); head.castShadow = true; reindeerGroup.add(head);
            // Ears
            const earGeo = new THREE.BoxGeometry(0.1, 0.4, 0.2);
            const earL = new THREE.Mesh(earGeo, matStandard(COLORS.reindeer)); earL.position.set(0.5, 2.5, -1.5); earL.rotation.z = 0.5; reindeerGroup.add(earL);
            const earR = new THREE.Mesh(earGeo, matStandard(COLORS.reindeer)); earR.position.set(-0.5, 2.5, -1.5); earR.rotation.z = -0.5; reindeerGroup.add(earR);
            // Nose
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 2 });
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.18, 8, 8), noseMat);
            nose.position.set(0, 2.2, -2.4); reindeerGroup.add(nose);
            // Legs
            const legMat = matStandard(COLORS.reindeer);
            const hoofMat = matStandard(0x111111);
            const createLeg = (x, z) => {
                const g = new THREE.Group();
                g.position.set(x, 0.6, z);
                const upper = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.8, 0.35), legMat); upper.position.y = -0.2;
                const hoof = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), hoofMat); hoof.position.y = -0.7;
                g.add(upper, hoof);
                return g;
            };
            reindeerGroup.add(createLeg(-0.4, -0.8)); reindeerGroup.add(createLeg(0.4, -0.8));
            reindeerGroup.add(createLeg(-0.4, 0.9));  reindeerGroup.add(createLeg(0.4, 0.9));
            // Antlers
            const antlerMat = matStandard(COLORS.antler);
            const createAntler = (side) => {
                const g = new THREE.Group();
                const main = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.2, 0.1), antlerMat);
                main.position.y = 0.6; main.rotation.z = side * 0.4; g.add(main);
                const prong1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.1), antlerMat);
                prong1.position.set(side*0.3, 0.4, 0.2); prong1.rotation.x = 0.5; g.add(prong1);
                const prong2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.1), antlerMat);
                prong2.position.set(side*0.4, 0.8, -0.1); prong2.rotation.z = side*0.5; g.add(prong2);
                return g;
            }
            const aL = createAntler(1); aL.position.set(0.2, 2.6, -1.6); reindeerGroup.add(aL);
            const aR = createAntler(-1); aR.position.set(-0.2, 2.6, -1.6); reindeerGroup.add(aR);
            player.add(reindeerGroup);
            reindeer = reindeerGroup;

            // --- SANTA ---
            const santaGroup = new THREE.Group();
            santaGroup.position.set(0, 1.6, 0.3);
            // Body
            const torso = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.3, 1), matStandard(COLORS.santaRed));
            torso.position.y = 0.65; torso.castShadow = true; santaGroup.add(torso);
            // Trim
            const trim = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.31, 1.05), matStandard(0xffffff));
            trim.position.y = 0.65; santaGroup.add(trim);
            // Belt
            const belt = new THREE.Mesh(new THREE.BoxGeometry(1.25, 0.25, 1.05), matStandard(0x111111));
            belt.position.y = 0.5; santaGroup.add(belt);
            const buckle = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 1.1), matStandard(COLORS.gold));
            buckle.position.y = 0.5; santaGroup.add(buckle);
            // Head
            const headS = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), matStandard(COLORS.skin));
            headS.position.y = 1.5; santaGroup.add(headS);
            // Beard
            const beard = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.7, 0.4), matStandard(0xffffff));
            beard.position.set(0, 1.3, -0.4); santaGroup.add(beard);
            // Hat
            const hatGroup = new THREE.Group();
            hatGroup.position.y = 2.0;
            const hatRim = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.2, 12), matStandard(0xffffff));
            hatGroup.add(hatRim);
            const hatCone = new THREE.Mesh(new THREE.ConeGeometry(0.5, 0.9, 12), matStandard(COLORS.santaRed));
            hatCone.position.set(0, 0.5, -0.1); hatCone.rotation.x = -0.2; hatGroup.add(hatCone);
            const pom = new THREE.Mesh(new THREE.SphereGeometry(0.2), matStandard(0xffffff));
            pom.position.set(0, 0.95, -0.3); hatGroup.add(pom);
            santaGroup.add(hatGroup);
            // Arms & Mittens
            const armGeo = new THREE.BoxGeometry(0.35, 0.9, 0.35);
            const armL = new THREE.Mesh(armGeo, matStandard(COLORS.santaRed)); armL.position.set(0.75, 0.8, 0); armL.rotation.z = -0.2; santaGroup.add(armL);
            const armR = new THREE.Mesh(armGeo, matStandard(COLORS.santaRed)); armR.position.set(-0.75, 0.8, 0); armR.rotation.z = 0.2; santaGroup.add(armR);
            const mitGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const mitL = new THREE.Mesh(mitGeo, matStandard(0x166534)); mitL.position.set(0.85, 0.3, 0); santaGroup.add(mitL);
            const mitR = new THREE.Mesh(mitGeo, matStandard(0x166534)); mitR.position.set(-0.85, 0.3, 0); santaGroup.add(mitR);
            // Legs
            const bootGeo = new THREE.BoxGeometry(0.4, 0.6, 0.5);
            const bootL = new THREE.Mesh(bootGeo, matStandard(0x111111)); bootL.position.set(0.3, 0.3, 0.3); santaGroup.add(bootL);
            const bootR = new THREE.Mesh(bootGeo, matStandard(0x111111)); bootR.position.set(-0.3, 0.3, 0.3); santaGroup.add(bootR);

            player.add(santaGroup);
            scene.add(player);
        }

        // --- ENVIRONMENT & SPAWNING ---
        function spawnGroundSegment(zPos) {
            const group = new THREE.Group();
            group.position.z = zPos;

            // Roof
            const base = new THREE.Mesh(new THREE.BoxGeometry(18, 2, 12), new THREE.MeshStandardMaterial({ color: COLORS.roofDark }));
            base.position.y = -1.5; base.receiveShadow = true; group.add(base);
            const snow = new THREE.Mesh(new THREE.BoxGeometry(18.4, 0.5, 12), new THREE.MeshStandardMaterial({ color: COLORS.snow, roughness: 0.9 }));
            snow.position.y = -0.25; snow.receiveShadow = true; group.add(snow);

            // Windows on current roof
            [-1, 1].forEach(side => {
                for(let k=0; k<2; k++) {
                    const win = new THREE.Mesh(new THREE.PlaneGeometry(1, 1.5), windowMaterial);
                    win.position.set((9.1) * side, -1.5, (k*5) - 2.5);
                    win.rotation.y = side * Math.PI/2;
                    group.add(win);
                }
            });

            // --- BACKGROUND SCENERY (HOUSES & TREES) ---
            [-1, 1].forEach(side => {
                const offset = (18/2 + 5 + Math.random() * 5) * side;
                if (Math.random() > 0.5) {
                    // Detailed Tree
                    const treeGroup = new THREE.Group();
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 2, 5), new THREE.MeshStandardMaterial({color: 0x3e2723}));
                    const leaves = new THREE.Mesh(new THREE.ConeGeometry(2.5, 6, 6), new THREE.MeshStandardMaterial({color: COLORS.tree, flatShading:true}));
                    leaves.position.y = 3;
                    const snowTop = new THREE.Mesh(new THREE.ConeGeometry(2.6, 1.5, 6), new THREE.MeshStandardMaterial({color: COLORS.snow}));
                    snowTop.position.y = 3.5;
                    treeGroup.add(trunk, leaves, snowTop);
                    treeGroup.position.set(offset, -2, 0);
                    group.add(treeGroup);
                } else {
                    // Detailed Distant House
                    const houseGroup = new THREE.Group();
                    const houseH = 4 + Math.random() * 4;
                    const house = new THREE.Mesh(new THREE.BoxGeometry(6, houseH, 6), new THREE.MeshStandardMaterial({ color: COLORS.roofDark, flatShading: true }));
                    house.position.y = houseH/2; houseGroup.add(house);
                    const roofCone = new THREE.Mesh(new THREE.ConeGeometry(4.5, 3, 4), new THREE.MeshStandardMaterial({color: COLORS.roof}));
                    roofCone.position.y = houseH + 1.5; roofCone.rotation.y = Math.PI/4; houseGroup.add(roofCone);
                    const distantWin = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 2), windowMaterial);
                    distantWin.position.set(0, houseH/2, 3.1); houseGroup.add(distantWin);
                    houseGroup.position.set(offset, -houseH - 1, 0);
                    group.add(houseGroup);
                }
            });

            scene.add(group);
            groundSegments.push(group);

            if (zPos < -20) {
                maybeSpawnObstacle(zPos);
                maybeSpawnGift(zPos);
            }
        }

        function maybeSpawnObstacle(zPos) {
            if (Math.random() > 0.5) return; 

            const laneIndex = Math.floor(Math.random() * 3);
            const laneX = LANES[laneIndex];
            const rand = Math.random();

            let obstacle;
            const matBrick = new THREE.MeshStandardMaterial({ color: COLORS.brick });
            const matMetal = new THREE.MeshStandardMaterial({ color: 0x64748b });

            if (rand < 0.4) {
                // Chimney (Detailed)
                const group = new THREE.Group();
                const base = new THREE.Mesh(new THREE.BoxGeometry(2.2, 3.5, 2.2), matBrick);
                base.position.y = 1.75; base.castShadow = true; group.add(base);
                const rim = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.4, 2.5), matBrick);
                rim.position.y = 3.5; group.add(rim);
                const cap = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.3, 2.4), new THREE.MeshStandardMaterial({color: COLORS.snow}));
                cap.position.y = 3.8; group.add(cap);
                const hole = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.1, 1.5), new THREE.MeshStandardMaterial({color: 0x111111}));
                hole.position.y = 3.96; group.add(hole);
                group.position.set(laneX, -0.5, zPos);
                group.userData = { type: 'chimney' };
                obstacle = group;
            } else if (rand < 0.7) {
                // Antenna
                const group = new THREE.Group();
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 2, 8), matMetal);
                pole.position.y = 1; group.add(pole);
                const dish = new THREE.Mesh(new THREE.ConeGeometry(1.2, 0.5, 16, 1, true), matMetal);
                dish.position.set(0, 1.8, 0.2); dish.rotation.x = -0.5; group.add(dish);
                group.position.set(laneX, -0.5, zPos);
                group.userData = { type: 'antenna' };
                obstacle = group;
            } else {
                // Drone (High Flying - 4.5)
                const group = new THREE.Group();
                const body = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshStandardMaterial({color: COLORS.droneMetal}));
                group.add(body);
                const propGeo = new THREE.BoxGeometry(2.2, 0.1, 0.2);
                const propMat = new THREE.MeshStandardMaterial({color: 0x111111});
                const p1 = new THREE.Mesh(propGeo, propMat); p1.position.y = 0.4; group.add(p1);
                const p2 = new THREE.Mesh(propGeo, propMat); p2.position.y = 0.4; p2.rotation.y = Math.PI/2; group.add(p2);
                const light = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color: 0xff0000}));
                light.position.y = -0.5; group.add(light);
                group.position.set(laneX, 4.5, zPos); 
                group.userData = { type: 'drone' };
                obstacle = group;
            }
            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        function maybeSpawnGift(zPos) {
            if (Math.random() > 0.3) return; 
            let freeLanes = [0, 1, 2].filter(l => !obstacles.some(o => Math.abs(o.position.z - zPos) < 2 && Math.abs(o.position.x - LANES[l]) < 2));
            if (freeLanes.length > 0) {
                const laneIndex = freeLanes[Math.floor(Math.random() * freeLanes.length)];
                const laneX = LANES[laneIndex];
                const color = COLOR_GIFT_BOX[Math.floor(Math.random() * COLOR_GIFT_BOX.length)];
                const gift = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.3 }));
                gift.position.set(laneX, 1.2, zPos);
                gift.userData = { type: 'gift', startY: 1.2, floatOffset: Math.random() * Math.PI };
                scene.add(gift);
                collectables.push(gift);
            }
        }

        function createSnow() {
            const geo = new THREE.BufferGeometry();
            const count = 2000;
            const positions = new Float32Array(count * 3);
            const velocities = [];
            for(let i=0; i<count; i++) {
                positions[i*3] = (Math.random() - 0.5) * 150; 
                positions[i*3+1] = Math.random() * 80;     
                positions[i*3+2] = (Math.random() - 0.5) * 120 - 20; 
                velocities.push((Math.random() * 0.2) + 0.1);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.6, map: glowTexture, transparent: true, opacity: 0.8, depthWrite: false, blending: THREE.AdditiveBlending });
            const points = new THREE.Points(geo, mat);
            points.userData = { velocities: velocities };
            scene.add(points);
            particles.push(points);
        }

        function updateSnow() {
            const points = particles[0];
            const positions = points.geometry.attributes.position.array;
            const vels = points.userData.velocities;
            for(let i=0; i<vels.length; i++) {
                let idx = i * 3;
                positions[idx+1] -= vels[i]; positions[idx] -= 0.03; 
                if (positions[idx+1] < 0) { positions[idx+1] = 60; positions[idx] = (Math.random() - 0.5) * 120; }
            }
            points.geometry.attributes.position.needsUpdate = true;
        }

        function updateDayNight() {
            const cycle = Math.floor(distance / 1000);
            const isDay = cycle % 2 === 0;
            const lerpSpeed = 0.01;

            const targetSky = isDay ? new THREE.Color(COLORS.skyDay) : new THREE.Color(COLORS.skyNight);
            const targetSunColor = isDay ? new THREE.Color(COLORS.sun) : new THREE.Color(COLORS.moon);
            const targetGlowColor = isDay ? new THREE.Color(0xffaa00) : new THREE.Color(0xffffee);

            scene.background.lerp(targetSky, lerpSpeed);
            scene.fog.color.lerp(targetSky, lerpSpeed);
            hemiLight.intensity += ((isDay ? 2.5 : 1.5) - hemiLight.intensity) * lerpSpeed;
            dirLight.intensity += ((isDay ? 3.0 : 2.5) - dirLight.intensity) * lerpSpeed;
            dirLight.color.lerp(isDay ? new THREE.Color(0xffffff) : new THREE.Color(0xc7d2fe), lerpSpeed);
            sunMoon.material.color.lerp(targetSunColor, lerpSpeed);
            sunMoon.children[0].material.color.lerp(targetGlowColor, lerpSpeed);
            
            if(stars) stars.material.opacity += ((isDay ? 0 : 1) - stars.material.opacity) * lerpSpeed;
            if(windowMaterial) windowMaterial.emissiveIntensity += ((isDay ? 0 : 0.8) - windowMaterial.emissiveIntensity) * lerpSpeed;
        }

        function startGame() {
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            hudEl.classList.remove('hidden');
            gameActive = true;
            distance = 0;
            reviveCount = 0; 
            gameSpeed = SPEED_INITIAL;
            playerLane = 1;
            targetX = 0;
            player.position.set(0, 0, 0);
            player.rotation.z = 0;
            obstacles.forEach(o => scene.remove(o));
            collectables.forEach(c => scene.remove(c));
            groundSegments.forEach(g => scene.remove(g));
            obstacles = []; collectables = []; groundSegments = [];
            for (let i = 0; i < 15; i++) spawnGroundSegment(-i * 12);
            if (!animationId) animate();
        }

        function resetGame() { startGame(); }
        function returnToMenu() {
            gameActive = false;
            gameOverScreen.classList.add('hidden');
            hudEl.classList.add('hidden');
            startScreen.classList.remove('hidden');
            updateWalletUI();
        }

        function continueGame() {
            const cost = 10 * (reviveCount + 1);
            if (totalWallet >= cost) {
                totalWallet -= cost;
                localStorage.setItem('santaRunnerGifts', totalWallet);
                updateWalletUI();
                reviveCount++;
                gameOverScreen.classList.add('hidden');
                hudEl.classList.remove('hidden');
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    let ob = obstacles[i];
                    if (ob.position.z > -30 && ob.position.z < 10) {
                        scene.remove(ob); obstacles.splice(i, 1);
                    }
                }
                playerLane = 1; targetX = 0;
                player.position.set(0, 0, 0); player.rotation.z = 0;
                verticalVelocity = 0; isJumping = false; isRolling = false;
                player.scale.set(1, 1, 1);
                gameActive = true;
            }
        }

        function gameOver() {
            gameActive = false;
            gameOverScreen.classList.remove('hidden');
            hudEl.classList.add('hidden');
            finalDistEl.innerText = Math.floor(distance) + "m";
            updateWalletUI();
            const cost = 10 * (reviveCount + 1);
            continueBtn.innerHTML = `Continue <span style="font-size: 0.8em; opacity: 0.9">(${cost} üéÅ)</span>`;
            continueBtn.disabled = totalWallet < cost;
        }

        function updatePhysics() {
            if (!gameActive) return;
            if (gameSpeed < SPEED_MAX) gameSpeed += 0.00015;
            distance += gameSpeed;
            distCountEl.innerText = Math.floor(distance);
            updateDayNight();

            player.position.x += (targetX - player.position.x) * 0.15;
            player.rotation.z = (player.position.x - targetX) * -0.05; 
            
            if (!isJumping) {
                 const time = Date.now() * 0.015;
                 player.position.y = Math.sin(time) * 0.15;
            } else {
                player.position.y += verticalVelocity;
                verticalVelocity -= GRAVITY;
                if (player.position.y <= 0) {
                    player.position.y = 0; isJumping = false; verticalVelocity = 0;
                    player.scale.set(1.2, 0.8, 1.2);
                    setTimeout(() => player.scale.set(1,1,1), 100);
                }
            }

            if (isRolling) {
                rollTimer--;
                if (rollTimer <= 0) {
                    isRolling = false; player.scale.y = 1; if(!isJumping) player.position.y = 0;
                }
            }

            groundSegments.forEach((g) => { g.position.z += gameSpeed; });
            if (groundSegments[0].position.z > 15) {
                const oldSeg = groundSegments.shift(); scene.remove(oldSeg);
                let minZ = 0; groundSegments.forEach(g => { if(g.position.z < minZ) minZ = g.position.z });
                spawnGroundSegment(minZ - 12);
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let ob = obstacles[i];
                ob.position.z += gameSpeed;
                
                if (ob.userData.type === 'drone') {
                   ob.children[1].rotation.y += 0.3;
                   ob.children[2].rotation.y += 0.3;
                }

                if (ob.position.z > -1 && ob.position.z < 1) {
                    if (Math.abs(ob.position.x - player.position.x) < 0.8) {
                        let collision = true;
                        
                        if (ob.userData.type === 'antenna' && player.position.y > 2) collision = false;
                        if (ob.userData.type === 'chimney' && player.position.y > 4.0) collision = false;

                        // DRONE COLLISION: Only kill if JUMPING (y >= 1.0)
                        if (ob.userData.type === 'drone') {
                             if (player.position.y < 1.0) collision = false;
                        }

                        if (collision) gameOver();
                    }
                }
                if (ob.position.z > 15) { scene.remove(ob); obstacles.splice(i, 1); }
            }

            for (let i = collectables.length - 1; i >= 0; i--) {
                let c = collectables[i];
                c.position.z += gameSpeed;
                c.rotation.y += 0.05;
                c.position.y = c.userData.startY + Math.sin(Date.now() * 0.005 + c.userData.floatOffset) * 0.3;
                if (c.position.z > -1.5 && c.position.z < 1.5) {
                    if (Math.abs(c.position.x - player.position.x) < 1.8 && Math.abs(c.position.y - player.position.y) < 2.5) {
                        scene.remove(c); collectables.splice(i, 1);
                        totalWallet++; localStorage.setItem('santaRunnerGifts', totalWallet);
                        updateWalletUI();
                    }
                }
                if (c.position.z > 15) { scene.remove(c); collectables.splice(i, 1); }
            }
            updateSnow();
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function handleInput(action) {
            if (!gameActive) return;
            switch(action) {
                case 'left': if (playerLane > 0) { playerLane--; targetX = LANES[playerLane]; } break;
                case 'right': if (playerLane < 2) { playerLane++; targetX = LANES[playerLane]; } break;
                case 'up': if (!isJumping) { isJumping = true; verticalVelocity = JUMP_FORCE; } break;
                case 'down': if (!isJumping && !isRolling) { isRolling = true; rollTimer = 40; player.scale.y = 0.5; player.position.y = -0.25; } break;
            }
        }
        function handleKeyDown(e) {
            if (e.key === 'ArrowLeft' || e.key === 'a') handleInput('left');
            if (e.key === 'ArrowRight' || e.key === 'd') handleInput('right');
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') handleInput('up');
            if (e.key === 'ArrowDown' || e.key === 's') handleInput('down');
        }
        function setupTouchControls() {
            let touchStartX = 0; let touchStartY = 0;
            document.addEventListener('touchstart', function(e) { touchStartX = e.changedTouches[0].screenX; touchStartY = e.changedTouches[0].screenY; }, false);
            document.addEventListener('touchend', function(e) {
                let touchEndX = e.changedTouches[0].screenX; let touchEndY = e.changedTouches[0].screenY;
                handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
            }, false);
        }
        function handleSwipe(startX, startY, endX, endY) {
            const dx = endX - startX; const dy = endY - startY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > 30) { if (dx > 0) handleInput('right'); else handleInput('left'); }
            } else {
                if (Math.abs(dy) > 30) { if (dy < 0) handleInput('up'); else handleInput('down'); }
            }
        }
        init();
    </script>
</body>
</html>